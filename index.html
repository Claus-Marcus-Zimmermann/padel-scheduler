<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Padel Doubles Scheduler</title>
<style>
body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    background: #f5f5f5;
}
.container {
    max-width: 900px;
    margin: auto;
    padding: 20px;
}
h1 { text-align: center; }

/* Panels */
.section {
    margin-bottom: 20px;
    padding: 10px;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* Collapsible panels */
details.section { padding: 0; }
details.section > summary {
    list-style: none;
    cursor: pointer;
    user-select: none;
    padding: 12px 10px;
    font-size: 20px;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: space-between;
}
details.section > summary::-webkit-details-marker { display: none; }
details.section > summary::after {
    content: "▸";
    font-size: 18px;
    opacity: 0.75;
    transform: translateY(-1px);
}
details.section[open] > summary::after { content: "▾"; }
.details-content {
    padding: 10px;
    border-top: 1px solid #eee;
}

label { display: block; margin-top: 6px; }
input[type="text"], input[type="number"], input[type="time"], input[type="date"], select {
    width: 100%;
    padding: 6px;
    margin-top: 2px;
    box-sizing: border-box;
}
button {
    margin-top: 10px;
    padding: 8px 14px;
    font-size: 14px;
}

.player-list { list-style: none; padding: 0; margin: 0; }
.player-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0;
    border-bottom: 1px solid #eee;
}
.player-item input { margin-right: 8px; }

.history-table {
    width: 100%;
    border-collapse: collapse;
}
.history-table th,
.history-table td {
    padding: 8px;
    border: 1px solid #ccc;
    text-align: left;
    vertical-align: top;
}
.history-table th { background: #eee; }

.toggle-container {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
}
.row {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}
.row > .col {
    flex: 1;
    min-width: 160px;
}

.build-info {
    margin-top: 8px;
    font-size: 12px;
    opacity: 0.75;
}

.schedules-actions {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    flex-wrap: wrap;
    margin-bottom: 10px;
}
.schedules-actions .left {
    display: flex;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
}
.hint {
    font-size: 12px;
    opacity: 0.75;
}

/* Session separator + label */
.session-sep td {
    padding: 0 !important;
    border-left: none !important;
    border-right: none !important;
    border-bottom: none !important;
    border-top: 5px solid #333 !important;
    height: 0;
    background: transparent;
}
.session-label td {
    border-left: none !important;
    border-right: none !important;
    border-top: none !important;
    background: rgba(0,0,0,0.04);
    font-weight: bold;
}
.session-label .meta {
    font-weight: normal;
    opacity: 0.8;
    margin-left: 6px;
    font-size: 12px;
}


@media (prefers-color-scheme: dark) {
    body { background: #111; color: #eee; }
    .section { background: #222; box-shadow: none; }
    .details-content { border-top-color: #333; }
    input, select {
        background: #333;
        color: #eee;
        border: 1px solid #555;
    }
    button { background: #444; color: #eee; border: 1px solid #666; }
    .history-table th { background: #333; }
    .history-table td { border-color: #444; }
    .session-sep td { border-top-color: #eee !important; }
    .session-label td { background: rgba(255,255,255,0.06); }
}

.scores-table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 8px;
}
.scores-table th, .scores-table td {
  padding: 6px 8px;
  border: 1px solid #ccc;
}
.scores-table th { background: #eee; }
.score-actions button {
  margin-top: 0;
  padding: 6px 10px;
  font-size: 13px;
}
.score-chip {
  display: inline-block;
  padding: 2px 8px;
  border: 1px solid #999;
  border-radius: 999px;
  font-size: 12px;
  opacity: 0.9;
}
@media (prefers-color-scheme: dark) {
  .scores-table th { background: #333; }
  .scores-table td, .scores-table th { border-color: #444; }
  .score-chip { border-color: #aaa; }
}

.icon-btn {
  padding: 4px;
  margin: 0 2px;
  border: 1px solid #999;
  background: transparent;
  border-radius: 6px;
  cursor: pointer;
}

.icon-btn img {
  width: 16px;
  height: 16px;
  display: block;
}

.icon-btn:hover {
  background: rgba(0,0,0,0.05);
}

.icon-btn.danger:hover {
  background: rgba(255,0,0,0.1);
}


</style>
</head>
<body>
<div class="container">
<h1>Padel Doubles Scheduler</h1>

<!-- Players (collapsed by default) -->
<details class="section" id="players-section">
  <summary>Players</summary>
  <div class="details-content">
    <label for="playerName">Add Player:</label>
    <div style="display:flex; gap:6px; flex-wrap:wrap;">
      <input type="text" id="playerName" placeholder="Player name" style="flex:1; min-width:220px;">
      <button id="addPlayerBtn">Add</button>
    </div>
    <ul id="playerList" class="player-list"></ul>
  </div>
</details>

<!-- Settings (collapsed by default) -->
<details class="section" id="settings-section">
  <summary>Settings</summary>
  <div class="details-content">
    <label>Session start (date + time):</label>
    <div class="row">
      <div class="col"><input type="date" id="startDate"></div>
      <div class="col"><input type="time" id="startTime"></div>
    </div>
    <div class="hint">
      Date/time is used only for the <strong>first round</strong> of a session. After that, times increment using last end + changeover.
    </div>

    <label for="gameDuration">Game duration (minutes):</label>
    <input type="number" id="gameDuration" min="1" value="20">

    <label for="changeoverDuration">Changeover time (minutes):</label>
    <input type="number" id="changeoverDuration" min="0" value="5">

    <label>Randomness:</label>
    <div class="toggle-container">
      <label><input type="radio" name="randomMode" value="fun" checked> Fun random</label>
      <label><input type="radio" name="randomMode" value="fair"> Fair random</label>
    </div>

    <div class="build-info" id="buildInfo"></div>
  </div>
</details>

<!-- Schedules -->
<div class="section" id="history-section">
  <h2>Schedules</h2>
  <div id="sessionWindowInfo" class="build-info"></div>
  <div class="schedules-actions">
    <div class="left">
      <button id="generateRoundBtn">Generate Next Round</button>
      <button id="newSessionBtn" title="Start a brand new session using the current date/time settings">New Session</button>
      <button id="exportCsvBtn" title="Export schedules as CSV">Export CSV</button>
      <button id="clearAllBtn" title="Clear schedules only (players and settings stay)">Clear schedules</button>
    </div>
    <div class="hint">
      Tip: if you change the date/time and it jumps backwards or forwards past the expected next start, a <strong>new session</strong> will be created.
    </div>
  </div>

  <table class="history-table" id="historyTable">
    <thead>
    <tr>
      <th>Session</th>
      <th>Round</th>
      <th>Date</th>
      <th>Start</th>
      <th>End</th>
      <th>Team A</th>
      <th>Team A Score</th>
      <th>Team B</th>
      <th>Team B Score</th>
      <th>Sat Out</th>
      <th>Mode</th>
      <th style="width:90px;">Action</th>
    </tr>
    </thead>
    <tbody></tbody>
  </table>
  <div id="scoresSection" class="section" style="margin-top:12px;">
      <h3 style="margin:0 0 10px 0;">Scores</h3>
      <div class="hint">Scores are shown per session (and grand total at the bottom).</div>
      <div id="scoresContent" style="margin-top:10px;"></div>
  </div>

</div>

</div>

<script>
(function(){
/** =========================
 *  Build
 *  ========================= */
const BUILD_VERSION = "2026-01-02.2";
document.getElementById('buildInfo').textContent = "Build: " + BUILD_VERSION;

/** =========================
 *  DOM references
 *  ========================= */
const sessionWindowInfo = document.getElementById('sessionWindowInfo');

const scoresContent = document.getElementById('scoresContent');

const playerListElement = document.getElementById('playerList');
const historyTableBody = document.getElementById('historyTable').querySelector('tbody');

const addPlayerBtn = document.getElementById('addPlayerBtn');
const playerNameInput = document.getElementById('playerName');

const startDateInput = document.getElementById('startDate');
const startTimeInput = document.getElementById('startTime');
const gameDurationInput = document.getElementById('gameDuration');
const changeoverDurationInput = document.getElementById('changeoverDuration');

const generateRoundBtn = document.getElementById('generateRoundBtn');
const newSessionBtn = document.getElementById('newSessionBtn');
const exportCsvBtn = document.getElementById('exportCsvBtn');
const clearAllBtn = document.getElementById('clearAllBtn');

/** =========================
 *  Storage keys
 *  ========================= */
const KEY_PLAYERS = 'padelSchedulerPlayers';
const KEY_HISTORY = 'padelSchedulerHistory';
const KEY_PREFS = 'padelSchedulerPrefs';

/** =========================
 *  Data
 *  ========================= */
let players = [];
let history = [];
let lastRoundEnd = null;   // end-of-game (NOT incl changeover)
let lastRoundStart = null; // start-of-game
let currentSession = 1;

// runtime-only flag used by “New Session” button
let forceNewSessionStart = false;

/** =========================
 *  Preferences persisted
 *  ========================= */
let prefs = {
  startDate: '',           // YYYY-MM-DD (user setting; date for first round of session)
  startTime: '',           // HH:MM (user setting; time for first round of session)
  gameDuration: 20,
  changeoverDuration: 5,
  randomMode: 'fun',

  // Session metadata persisted
  sessionNumber: 1,
  sessionDateKey: '',      // YYYY-MM-DD (date of session start)
  sessionStartTime: ''     // HH:MM (time used for FIRST round of this session)
};

/** =========================
 *  Storage helpers
 *  ========================= */
function saveState() {
  localStorage.setItem(KEY_PLAYERS, JSON.stringify(players));
  localStorage.setItem(KEY_HISTORY, JSON.stringify(history));
}
function savePrefs() {
  localStorage.setItem(KEY_PREFS, JSON.stringify(prefs));
}

/** =========================
 *  Load state
 *  ========================= */
function loadState() {
  const storedPlayers = localStorage.getItem(KEY_PLAYERS);
  const storedHistory = localStorage.getItem(KEY_HISTORY);
  const storedPrefs = localStorage.getItem(KEY_PREFS);

  if (storedPlayers) {
    try { players = JSON.parse(storedPlayers); } catch (e) { players = []; }
  }
  if (storedHistory) {
    try { history = JSON.parse(storedHistory); } catch (e) { history = []; }
  }
  if (storedPrefs) {
    try {
      const p = JSON.parse(storedPrefs);
      if (p && typeof p === 'object') {
        if (typeof p.startDate === 'string') prefs.startDate = p.startDate;
        if (typeof p.startTime === 'string') prefs.startTime = p.startTime;
        if (Number.isFinite(p.gameDuration)) prefs.gameDuration = p.gameDuration;
        if (Number.isFinite(p.changeoverDuration)) prefs.changeoverDuration = p.changeoverDuration;
        if (p.randomMode === 'fun' || p.randomMode === 'fair') prefs.randomMode = p.randomMode;

        if (Number.isFinite(p.sessionNumber)) prefs.sessionNumber = p.sessionNumber;
        if (typeof p.sessionDateKey === 'string') prefs.sessionDateKey = p.sessionDateKey;
        if (typeof p.sessionStartTime === 'string') prefs.sessionStartTime = p.sessionStartTime;
      }
    } catch (e) { /* keep defaults */ }
  }

  // Defaults if missing
  if (!prefs.startDate) prefs.startDate = dateKeyYYYYMMDD(new Date());
  if (!prefs.startTime) prefs.startTime = defaultStartTimeHHMM();
  if (!prefs.sessionDateKey) prefs.sessionDateKey = prefs.startDate;
  if (!prefs.sessionStartTime) prefs.sessionStartTime = prefs.startTime;

  // Ensure player objects have required properties
  players.forEach(p => {
    if (typeof p.active === 'undefined') p.active = true;
    if (typeof p.games === 'undefined') p.games = 0;
    if (typeof p.sitouts === 'undefined') p.sitouts = 0;
  });

  // Ensure rounds have required properties
history.forEach(r => {
  if (!r.createdAt) r.createdAt = Date.now();
  if (!r.id) r.id = cryptoRandomId();
  if (!r.session) r.session = 1;
  if (!r.roundInSession) r.roundInSession = 1;

  // NEW: scores per round (default 0-0)
  if (!Number.isFinite(r.scoreA)) r.scoreA = 0;
  if (!Number.isFinite(r.scoreB)) r.scoreB = 0;
});


  // Determine last round times / session if any
  if (history.length > 0) {
    const lastByCreated = getLatestRound();
    lastRoundEnd = new Date(lastByCreated.end);
    lastRoundStart = new Date(lastByCreated.start);
    currentSession = lastByCreated.session || 1;

    prefs.sessionNumber = currentSession;

    // derive session metadata for current session from earliest start in that session
    const sessionRounds = history
      .filter(r => (r.session || 1) === currentSession)
      .map(r => new Date(r.start));
    if (sessionRounds.length > 0) {
      const minStart = sessionRounds.reduce((a,b) => a.getTime() < b.getTime() ? a : b, sessionRounds[0]);
      prefs.sessionDateKey = dateKeyYYYYMMDD(minStart);
      prefs.sessionStartTime = formatTimeHHMM(minStart);
    }

    savePrefs();
  } else {
    currentSession = prefs.sessionNumber || 1;
    savePrefs();
  }

  // Apply prefs to UI
  startDateInput.value = prefs.startDate || dateKeyYYYYMMDD(new Date());
  startTimeInput.value = prefs.startTime || defaultStartTimeHHMM();
  gameDurationInput.value = String(prefs.gameDuration);
  changeoverDurationInput.value = String(prefs.changeoverDuration);
  const modeRadio = document.querySelector('input[name="randomMode"][value="' + prefs.randomMode + '"]');
  if (modeRadio) modeRadio.checked = true;

  recomputePlayerStatsFromHistory();
}

/** =========================
 *  Render players
 *  ========================= */
function renderPlayers() {
      playerListElement.innerHTML = '';
      players.forEach((player, index) => {
        const li = document.createElement('li');
        li.className = 'player-item';

        const nameSpan = document.createElement('span');
        nameSpan.textContent = player.name + (player.active ? '' : ' (inactive)');
        if (!player.active) nameSpan.style.opacity = '0.5';

        const controlsDiv = document.createElement('div');

        const activeToggle = document.createElement('input');
        activeToggle.type = 'checkbox';
        activeToggle.checked = player.active;
        activeToggle.title = 'Toggle player active status';
        activeToggle.addEventListener('change', () => {
          player.active = activeToggle.checked;
          saveState();
          renderPlayers();
        });

        const removeBtn = document.createElement('button');
        removeBtn.textContent = 'Remove';
        removeBtn.title = 'Remove player';
        removeBtn.addEventListener('click', () => {
          players.splice(index, 1);
          saveState();
          renderPlayers();
          renderHistory();
        });

        controlsDiv.appendChild(activeToggle);
        controlsDiv.appendChild(removeBtn);

        li.appendChild(nameSpan);
        li.appendChild(controlsDiv);
        playerListElement.appendChild(li);
      });
    }

    function addScore(roundId, team, delta) {
      const r = history.find(x => x.id === roundId);
      if (!r) return;

      if (!Number.isFinite(r.scoreA)) r.scoreA = 0;
      if (!Number.isFinite(r.scoreB)) r.scoreB = 0;

      if (team === 'A') r.scoreA = Math.max(0, r.scoreA + delta);
      if (team === 'B') r.scoreB = Math.max(0, r.scoreB + delta);

      saveState();
      renderHistory(); // calls renderScores() at the end
    }

    function resetRoundScore(roundId) {
      const r = history.find(x => x.id === roundId);
      if (!r) return;
      r.scoreA = 0;
      r.scoreB = 0;
      saveState();
      renderHistory();
    }

    function renderScores() {
      if (!scoresContent) return;

      if (!history.length) {
        scoresContent.innerHTML = '<div class="hint">No scores yet.</div>';
        return;
      }

      // session -> { playerName -> points }
      const perSession = {};
      const grand = {};

      function inc(map, name, pts) {
        map[name] = (map[name] || 0) + pts;
      }

      // Build from rounds
      history.forEach(r => {
        const s = r.session || 1;
        if (!perSession[s]) perSession[s] = {};

        const aPts = Number.isFinite(r.scoreA) ? r.scoreA : 0;
        const bPts = Number.isFinite(r.scoreB) ? r.scoreB : 0;

        const teamA = r.teamA || [];
        const teamB = r.teamB || [];

        teamA.forEach(name => {
          inc(perSession[s], name, aPts);
          inc(grand, name, aPts);
        });
        teamB.forEach(name => {
          inc(perSession[s], name, bPts);
          inc(grand, name, bPts);
        });
      });

      // Sort sessions ascending
      const sessions = Object.keys(perSession).map(n => parseInt(n, 10)).sort((a,b) => a-b);

      const parts = [];

      sessions.forEach(sess => {
        const map = perSession[sess];

        // list players that appear in this session
        const playersInSession = Object.keys(map).sort((a,b) => (map[b]-map[a]) || a.localeCompare(b));

        parts.push(`<div style="margin-top:12px;"><strong>Session ${sess}</strong></div>`);
        parts.push(`<table class="scores-table">
          <thead><tr><th>Player</th><th>Points</th></tr></thead><tbody>
        `);

        let sessionTotal = 0;
        playersInSession.forEach(name => {
          const pts = map[name] || 0;
          sessionTotal += pts;
          parts.push(`<tr><td>${escapeHtml(name)}</td><td>${pts}</td></tr>`);
        });

        parts.push(`<tr><th>Total</th><th>${sessionTotal}</th></tr>`);
        parts.push(`</tbody></table>`);
      });

      // Grand total table
      const grandPlayers = Object.keys(grand).sort((a,b) => (grand[b]-grand[a]) || a.localeCompare(b));
      parts.push(`<div style="margin-top:16px;"><strong>Grand total</strong></div>`);
      parts.push(`<table class="scores-table">
        <thead><tr><th>Player</th><th>Points</th></tr></thead><tbody>
      `);

      let grandTotal = 0;
      grandPlayers.forEach(name => {
        const pts = grand[name] || 0;
        grandTotal += pts;
        parts.push(`<tr><td>${escapeHtml(name)}</td><td>${pts}</td></tr>`);
      });
      parts.push(`<tr><th>Total</th><th>${grandTotal}</th></tr>`);
      parts.push(`</tbody></table>`);

      scoresContent.innerHTML = parts.join('');
    }

    function escapeHtml(s) {
      return String(s ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    function getSessionThatContains(desiredStartDateTime, changeoverMinsOverride) {
      // Use current UI changeover value if provided, otherwise prefs
      const changeoverMins = Number.isFinite(changeoverMinsOverride)
        ? changeoverMinsOverride
        : (prefs.changeoverDuration || 0);

      // Build session set
      const sessions = new Set(history.map(r => r.session || 1));

      for (const sess of sessions) {
        const bounds = getSessionBounds(sess);
        if (!bounds) continue;

        const start = bounds.minStart;
        const endPlus = new Date(bounds.maxEnd.getTime() + changeoverMins * 60 * 1000);

        const t = desiredStartDateTime.getTime();

        // IMPORTANT: inclusive window block
        // If user chooses EXACTLY start or EXACTLY end+changeover, we treat it as "inside" to prevent overlaps/duplicates.
        if (t >= start.getTime() && t <= endPlus.getTime()) {
          return { session: sess, start, endPlus };
        }
      }
      return null;
    }



/** =========================
 *  Sorting helper used by render + exports
 *  ========================= */
function getSortedRoundsForDisplay() {
  // Sort: date DESC, then time ASC
  return history.slice().sort((a, b) => {
    const aStart = new Date(a.start);
    const bStart = new Date(b.start);

    const aDateKey = dateKeyYYYYMMDD(aStart);
    const bDateKey = dateKeyYYYYMMDD(bStart);

    if (aDateKey !== bDateKey) return aDateKey < bDateKey ? 1 : -1; // date desc

    const aMin = aStart.getHours() * 60 + aStart.getMinutes();
    const bMin = bStart.getHours() * 60 + bStart.getMinutes();
    if (aMin !== bMin) return aMin - bMin; // time asc

    return (a.createdAt || 0) - (b.createdAt || 0);
  });
}

/** =========================
 *  Render schedules (history)
 *  - add thick separator + label between sessions
 *  ========================= */
function renderHistory() {
  historyTableBody.innerHTML = '';

// Show current session window (start → end+changeover)
if (!history.length) {
  sessionWindowInfo.textContent = 'Current session window: (none)';
} else {
  const bounds = getSessionBounds(currentSession || 1);
  if (!bounds) {
    sessionWindowInfo.textContent = 'Current session window: (unknown)';
  } else {
    const endPlus = new Date(bounds.maxEnd.getTime() + (prefs.changeoverDuration || 0) * 60 * 1000);
    sessionWindowInfo.textContent =
      'Current session window: ' +
      formatDateDDMMYYYY(bounds.minStart) + ' ' + formatTimeHHMM(bounds.minStart) +
      ' \u2192 ' +
      formatTimeHHMM(endPlus) + ' (end+changeover)';
  }
}


  const latestId = getLatestRoundId();

  const sorted = getSortedRoundsForDisplay();

  let lastSessionSeen = null;

  sorted.forEach((round) => {
    const sess = round.session || 1;

    if (lastSessionSeen !== null && sess !== lastSessionSeen) {
      // thick line
      const sep = document.createElement('tr');
      sep.className = 'session-sep';
      const td = document.createElement('td');
      td.colSpan = 12;
      sep.appendChild(td);
      historyTableBody.appendChild(sep);

      // label row for the new session we are about to render
      historyTableBody.appendChild(makeSessionLabelRow(sess));
    } else if (lastSessionSeen === null) {
      // first session label
      historyTableBody.appendChild(makeSessionLabelRow(sess));
    }

    lastSessionSeen = sess;

    const row = document.createElement('tr');

    const startDt = new Date(round.start);
    const endDt = new Date(round.end);

    const sessCell = document.createElement('td');
    sessCell.textContent = String(sess);

    const rndCell = document.createElement('td');
    rndCell.textContent = String(round.roundInSession || 1);

    const dateCell = document.createElement('td');
    dateCell.textContent = formatDateDDMMYYYY(startDt);

    const startCell = document.createElement('td');
    startCell.textContent = formatTimeHHMM(startDt);

    const endCell = document.createElement('td');
    endCell.textContent = formatTimeHHMM(endDt);

    const teamACell = document.createElement('td');
    teamACell.textContent = (round.teamA || []).join(' & ');

    const scoreACell = document.createElement('td');
    scoreACell.innerHTML = `<span class="score-chip">${round.scoreA ?? 0}</span>`;

    const teamBCell = document.createElement('td');
    teamBCell.textContent = (round.teamB || []).join(' & ');

    const scoreBCell = document.createElement('td');
    scoreBCell.innerHTML = `<span class="score-chip">${round.scoreB ?? 0}</span>`;

    const sitCell = document.createElement('td');
    sitCell.textContent = (round.satOut || []).join(', ');

    const modeCell = document.createElement('td');
    modeCell.textContent = round.mode || 'fun';

    const actionCell = document.createElement('td');
    actionCell.className = 'score-actions';

    // NEW: score buttons (available for every round)
    const aPlus = document.createElement('button');
    aPlus.textContent = 'A +1';
    aPlus.title = 'Add 1 point to Team A (both players)';
    aPlus.addEventListener('click', () => addScore(round.id, 'A', +1));

    const bPlus = document.createElement('button');
    bPlus.textContent = 'B +1';
    bPlus.title = 'Add 1 point to Team B (both players)';
    bPlus.addEventListener('click', () => addScore(round.id, 'B', +1));

    const resetBtn = document.createElement('button');
    resetBtn.className = 'icon-btn';
    resetBtn.title = 'Reset score';
    resetBtn.innerHTML = `<img src="icons/reset.svg" alt="Reset">`;
    resetBtn.addEventListener('click', () => resetRoundScore(round.id));
    
    actionCell.appendChild(aPlus);
    actionCell.appendChild(bPlus);
    actionCell.appendChild(resetBtn);

    // Keep your "Delete latest round" button too (optional)
    // If you want to keep it, add it after the score buttons:
    if (round.id === latestId) {
      const delBtn = document.createElement('button');
      delBtn.className = 'icon-btn danger';
      delBtn.title = 'Delete last session';
      delBtn.innerHTML = `<img src="icons/delete.svg" alt="Delete session">`;

      // ✅ ADD THIS LINE
      delBtn.addEventListener('click', deleteLatestSession);

      actionCell.appendChild(delBtn);
    }




        row.appendChild(sessCell);
        row.appendChild(rndCell);
        row.appendChild(dateCell);
        row.appendChild(startCell);
        row.appendChild(endCell);
        row.appendChild(teamACell);
        row.appendChild(scoreACell);
        row.appendChild(teamBCell);
        row.appendChild(scoreBCell);
        row.appendChild(sitCell);
        row.appendChild(modeCell);
        row.appendChild(actionCell);

        historyTableBody.appendChild(row);
      });

      renderScores();
}

function makeSessionLabelRow(sessionNumber) {
  const tr = document.createElement('tr');
  tr.className = 'session-label';
  const td = document.createElement('td');
  td.colSpan = 12;

  const meta = deriveSessionMeta(sessionNumber);
  const metaText = meta
    ? `(${meta.date || "?"} @ ${meta.time || "?"}, rounds: ${meta.roundCount})`
    : '';

  td.innerHTML = `Session ${sessionNumber} <span class="meta">${metaText}</span>`;
  tr.appendChild(td);
  return tr;
}

function deriveSessionMeta(sessionNumber) {
  const rounds = history
    .filter(r => (r.session || 1) === sessionNumber)
    .slice()
    .sort((a,b) => (a.createdAt || 0) - (b.createdAt || 0));

  if (rounds.length === 0) return null;

  const starts = rounds.map(r => new Date(r.start));
  const minStart = starts.reduce((a,b) => a.getTime() < b.getTime() ? a : b, starts[0]);

  return {
    date: formatDateDDMMYYYY(minStart),
    time: formatTimeHHMM(minStart),
    roundCount: rounds.length
  };
}

/** =========================
 *  Add player
 *  ========================= */
function addPlayer() {
  const name = playerNameInput.value.trim();
  if (!name) return;

  if (players.some(p => p.name.toLowerCase() === name.toLowerCase())) {
    alert('Player already exists.');
    return;
  }
  players.push({name: name, games: 0, sitouts: 0, active: true});
  playerNameInput.value = '';
  saveState();
  renderPlayers();
}

/** =========================
 *  Shuffle
 *  ========================= */
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

/** =========================
 *  Generate next round
 *  ========================= */
function generateNextRound() {
  const activePlayers = players.filter(p => p.active);
  if (activePlayers.length < 4) {
    alert('Need at least 4 active players to generate a round.');
    return;
  }

  // Capture & persist settings
  const inputStartDate = startDateInput.value || prefs.startDate || dateKeyYYYYMMDD(new Date());
  const inputStartTime = startTimeInput.value || prefs.startTime || defaultStartTimeHHMM();

  prefs.startDate = inputStartDate;
  prefs.startTime = inputStartTime;
  prefs.gameDuration = parseInt(gameDurationInput.value, 10) || prefs.gameDuration || 20;

  prefs.changeoverDuration = parseInt(changeoverDurationInput.value, 10);
  if (!Number.isFinite(prefs.changeoverDuration)) prefs.changeoverDuration = 5;

  prefs.randomMode = document.querySelector('input[name="randomMode"]:checked').value;
  savePrefs();

  const mode = prefs.randomMode;

  // Pick players
  let selectedPlayers = [];
  let satOutPlayers = [];

  if (activePlayers.length === 4) {
    selectedPlayers = activePlayers.slice();
  } else {
    const sorted = activePlayers.slice().sort((a,b) => {
      if (a.games !== b.games) return a.games - b.games;
      if (a.sitouts !== b.sitouts) return a.sitouts - b.sitouts;
      return Math.random() - 0.5;
    });

    const groupSize = 4;
    const numPlayers = Math.floor(sorted.length / groupSize) * groupSize;
    selectedPlayers = sorted.slice(0, numPlayers);
    satOutPlayers = sorted.slice(numPlayers);
  }

  let roundPlayers;
  if (selectedPlayers.length > 4) {
    roundPlayers = selectedPlayers.slice(0, 4);
    satOutPlayers = satOutPlayers.concat(selectedPlayers.slice(4));
  } else {
    roundPlayers = selectedPlayers;
  }

  // Assign teams
  let teamAssignment;
  if (mode === 'fair') {
    teamAssignment = chooseFairTeams(roundPlayers);
  } else {
    const arr = roundPlayers.slice();
    shuffleArray(arr);
    teamAssignment = {
      teamA: [arr[0].name, arr[1].name],
      teamB: [arr[2].name, arr[3].name]
    };
  }

  // Compute start/end/session
  const schedule = computeNextStartEndAndSession(
    inputStartDate,
    inputStartTime,
    prefs.gameDuration,
    prefs.changeoverDuration
  );

  const startTime = schedule.start;
  const endTime = schedule.end;
  const session = schedule.session;

  const roundInSession = nextRoundInSession(session);

  // Update stats
  roundPlayers.forEach(p => {
    const obj = players.find(pl => pl.name === p.name);
    if (obj) obj.games = (obj.games || 0) + 1;
  });
  satOutPlayers.forEach(p => {
    const obj = players.find(pl => pl.name === p.name);
    if (obj) obj.sitouts = (obj.sitouts || 0) + 1;
  });

  // Save schedule
  history.push({
    id: cryptoRandomId(),
    createdAt: Date.now(),
    session: session,
    roundInSession: roundInSession,
    start: startTime.toISOString(),
    end: endTime.toISOString(),
    teamA: teamAssignment.teamA,
    teamB: teamAssignment.teamB,
    satOut: satOutPlayers.map(p => p.name),
    mode: mode
  });

  currentSession = session;
  lastRoundStart = startTime;
  lastRoundEnd = endTime;

  saveState();
  savePrefs();
  renderPlayers();
  renderHistory();
}

/**
 * RULES
 * 1) Date+Time used only for first round of a session/day
 * 2) All following rounds use lastEnd + changeover
 * 3) New session if:
 *    - day changed (selected date != last round date), OR
 *    - user changed date/time AND it goes backwards, OR
 *    - user changed date/time AND it jumps forward past expected next start (lastEnd + changeover)
 * 4) “New Session” button always starts a new session at the selected date/time
 */
function computeNextStartEndAndSession(inputDateYYYYMMDD, inputStartHHMM, gameMins, changeoverMins) {
  const baseStart = combineDateAndTime(inputDateYYYYMMDD, inputStartHHMM);
  const desiredDayKey = dateKeyYYYYMMDD(baseStart);

  // Forced new session (button)
  if (forceNewSessionStart) {
    forceNewSessionStart = false;
    const nextSession = getMaxSessionNumber() + 1;
    resetPlayerStats();

    prefs.sessionNumber = nextSession;
    prefs.sessionDateKey = desiredDayKey;
    prefs.sessionStartTime = inputStartHHMM;
    currentSession = nextSession;

    return {
      session: nextSession,
      start: new Date(baseStart.getTime()),
      end: new Date(baseStart.getTime() + gameMins*60*1000)
    };
  }

  // No history => session 1
  if (!lastRoundStart || !lastRoundEnd || history.length === 0) {
    prefs.sessionNumber = 1;
    prefs.sessionDateKey = desiredDayKey;
    prefs.sessionStartTime = inputStartHHMM;
    currentSession = 1;

    return {
      session: 1,
      start: new Date(baseStart.getTime()),
      end: new Date(baseStart.getTime() + gameMins*60*1000)
    };
  }

  const lastStart = new Date(lastRoundStart.getTime());
  const lastEnd = new Date(lastRoundEnd.getTime());
  const lastDayKey = dateKeyYYYYMMDD(lastStart);

  // Expected next start if we continue current session
  const continueStart = new Date(lastEnd.getTime() + changeoverMins*60*1000);

  // Day changed (based on selected date) => new session
  if (desiredDayKey !== lastDayKey) {
    const nextSession = getMaxSessionNumber() + 1;
    resetPlayerStats();

    prefs.sessionNumber = nextSession;
    prefs.sessionDateKey = desiredDayKey;
    prefs.sessionStartTime = inputStartHHMM;
    currentSession = nextSession;

    return {
      session: nextSession,
      start: new Date(baseStart.getTime()),
      end: new Date(baseStart.getTime() + gameMins*60*1000)
    };
  }

  // Within same day: only create new session if user actually changed the session start setting
  const sessionStartTimeHHMM = prefs.sessionStartTime || inputStartHHMM;
  const sessionStartDateKey = prefs.sessionDateKey || desiredDayKey;

  const userChangedStartSetting =
    (desiredDayKey !== sessionStartDateKey) || (inputStartHHMM !== sessionStartTimeHHMM);

  const goesBackwards = baseStart.getTime() <= lastStart.getTime();
  const jumpsForwardPastSchedule = baseStart.getTime() > continueStart.getTime();

  if (userChangedStartSetting && (goesBackwards || jumpsForwardPastSchedule)) {
    const nextSession = getMaxSessionNumber() + 1;
    resetPlayerStats();

    prefs.sessionNumber = nextSession;
    prefs.sessionDateKey = desiredDayKey;
    prefs.sessionStartTime = inputStartHHMM;
    currentSession = nextSession;

    return {
      session: nextSession,
      start: new Date(baseStart.getTime()),
      end: new Date(baseStart.getTime() + gameMins*60*1000)
    };
  }

  // Otherwise continue normally
  prefs.sessionNumber = currentSession || 1;
  return {
    session: currentSession || 1,
    start: continueStart,
    end: new Date(continueStart.getTime() + gameMins*60*1000)
  };
}

function nextRoundInSession(session) {
  const max = history.reduce((m, r) => {
    if ((r.session || 1) !== session) return m;
    return Math.max(m, r.roundInSession || 1);
  }, 0);
  return max + 1;
}

/** =========================
 *  Fair teams
 *  ========================= */
function chooseFairTeams(roundPlayers) {
  const partnerCount = {};
  const opponentCount = {};

  function incPairCount(map, a, b) {
    const key = a < b ? a + '__' + b : b + '__' + a;
    map[key] = (map[key] || 0) + 1;
  }

  history.filter(r => (r.session || 1) === (currentSession || 1)).forEach(r => {
    if (r.teamA && r.teamB) {
      incPairCount(partnerCount, r.teamA[0], r.teamA[1]);
      incPairCount(partnerCount, r.teamB[0], r.teamB[1]);
      r.teamA.forEach(a => r.teamB.forEach(b => incPairCount(opponentCount, a, b)));
    }
  });

  function getPairCount(map, a, b) {
    const key = a < b ? a + '__' + b : b + '__' + a;
    return map[key] || 0;
  }

  const names = roundPlayers.map(p => p.name);
  const combinations = [
    {teamA: [names[0], names[1]], teamB: [names[2], names[3]]},
    {teamA: [names[0], names[2]], teamB: [names[1], names[3]]},
    {teamA: [names[0], names[3]], teamB: [names[1], names[2]]}
  ];

  let minPenalty = Infinity;
  let bestComb = combinations[0];

  combinations.forEach(comb => {
    let penalty = 0;
    penalty += getPairCount(partnerCount, comb.teamA[0], comb.teamA[1]) * 3;
    penalty += getPairCount(partnerCount, comb.teamB[0], comb.teamB[1]) * 3;
    comb.teamA.forEach(a => comb.teamB.forEach(b => penalty += getPairCount(opponentCount, a, b)));

    if (penalty < minPenalty) {
      minPenalty = penalty;
      bestComb = comb;
    } else if (penalty === minPenalty && Math.random() < 0.5) {
      bestComb = comb;
    }
  });

  return bestComb;
}

    /** =========================
     *  Delete latest round
     *  ========================= */
    function deleteLatestSession() {
      if (history.length === 0) return;

      // last session = session of most recently created round
      const latest = getLatestRound();
      if (!latest) return;

      const targetSession = latest.session || 1;

      const ok = confirm(`Delete Session ${targetSession}? This will remove ALL rounds (and scores) in that session.`);
      if (!ok) return;

      history = history.filter(r => (r.session || 1) !== targetSession);
      saveState();

      if (history.length === 0) {
        // everything gone
        lastRoundStart = null;
        lastRoundEnd = null;
        currentSession = 1;

        prefs.sessionNumber = 1;
        prefs.sessionDateKey = prefs.startDate || dateKeyYYYYMMDD(new Date());
        prefs.sessionStartTime = prefs.startTime || defaultStartTimeHHMM();
        savePrefs();
      } else {
        // point to new latest round/session
        const newLatest = getLatestRound();
        currentSession = newLatest.session || 1;
        lastRoundStart = new Date(newLatest.start);
        lastRoundEnd = new Date(newLatest.end);

        prefs.sessionNumber = currentSession;

        // derive session meta for current session
        const sessionRounds = history
          .filter(r => (r.session || 1) === currentSession)
          .map(r => new Date(r.start));

        if (sessionRounds.length > 0) {
          const minStart = sessionRounds.reduce((a,b) => a.getTime() < b.getTime() ? a : b, sessionRounds[0]);
          prefs.sessionDateKey = dateKeyYYYYMMDD(minStart);
          prefs.sessionStartTime = formatTimeHHMM(minStart);
        }

        savePrefs();
      }

      recomputePlayerStatsFromHistory();
      renderPlayers();
      renderHistory();
    }


/** =========================
 *  Suggestions: New Session / Export+Import JSON / Clear All / Export CSV
 *  ========================= */
function startNewSessionNow() {
  // Read UI values (NOT prefs) so validation is always correct
  const inputStartDate = startDateInput.value || prefs.startDate || dateKeyYYYYMMDD(new Date());
  const inputStartTime = startTimeInput.value || prefs.startTime || defaultStartTimeHHMM();

  const desiredStart = combineDateAndTime(inputStartDate, inputStartTime);

  // Use *current* changeover input for the window check
  let changeoverMins = parseInt(changeoverDurationInput.value, 10);
  if (!Number.isFinite(changeoverMins) || changeoverMins < 0) changeoverMins = (prefs.changeoverDuration || 0);

  // Block if the chosen time lands inside ANY session window (inclusive)
  const hit = getSessionThatContains(desiredStart, changeoverMins);
  if (hit) {
    alert(
      "New Session blocked.\n\n" +
      "That start time is inside an existing session window.\n\n" +
      "Session " + hit.session + " window:\n" +
      formatDateDDMMYYYY(hit.start) + " " + formatTimeHHMM(hit.start) +
      " \u2192 " +
      formatDateDDMMYYYY(hit.endPlus) + " " + formatTimeHHMM(hit.endPlus) +
      " (end + changeover)\n\n" +
      "Pick a start time BEFORE this window, or AFTER it."
    );
    return;
  }

  // Persist settings now (so the forced session uses what the user sees)
  prefs.startDate = inputStartDate;
  prefs.startTime = inputStartTime;

  const gd = parseInt(gameDurationInput.value, 10);
  if (Number.isFinite(gd) && gd > 0) prefs.gameDuration = gd;

  prefs.changeoverDuration = changeoverMins;
  prefs.randomMode = document.querySelector('input[name="randomMode"]:checked').value;
  savePrefs();

  // Force a new session and generate the first round in that new session
  forceNewSessionStart = true;
  generateNextRound();
}


function clearSchedulesOnly() {
  const ok = confirm("This will delete ALL schedules only. Players and settings will remain. Continue?");
  if (!ok) return;

  // Remove schedules only
  localStorage.removeItem(KEY_HISTORY);

  // Reset in-memory schedules + pointers
  history = [];
  lastRoundStart = null;
  lastRoundEnd = null;
  currentSession = 1;
  forceNewSessionStart = false;

  // Reset session metadata only (keep prefs/settings like date/time/durations/mode)
  prefs.sessionNumber = 1;
  prefs.sessionDateKey = prefs.startDate || dateKeyYYYYMMDD(new Date());
  prefs.sessionStartTime = prefs.startTime || defaultStartTimeHHMM();
  savePrefs();

  // Recompute stats now that schedules are gone
  recomputePlayerStatsFromHistory();

  renderPlayers();
  renderHistory();
}


function exportSchedulesToCsv() {
  const sorted = getSortedRoundsForDisplay();

    const header = [
      "Session",
      "Round",
      "Date",
      "Start",
      "End",
      "Team A",
      "Team A Score",
      "Team B",
      "Team B Score",
      "Sat Out",
      "Mode"
    ];


  const lines = [];
  lines.push(header.map(csvEscape).join(","));

  sorted.forEach(r => {
    const s = r.session || 1;
    const round = r.roundInSession || 1;
    const startDt = new Date(r.start);
    const endDt = new Date(r.end);

    const row = [
      String(s),
      String(round),
      formatDateDDMMYYYY(startDt),
      formatTimeHHMM(startDt),
      formatTimeHHMM(endDt),
      (r.teamA || []).join(" & "),
      String(Number.isFinite(r.scoreA) ? r.scoreA : 0),
      (r.teamB || []).join(" & "),
      String(Number.isFinite(r.scoreB) ? r.scoreB : 0),
      (r.satOut || []).join(", "),
      (r.mode || "fun")
    ];


    lines.push(row.map(csvEscape).join(","));
  });

  const csv = lines.join("\n");
  downloadTextFile(
    "padel-schedules-" + safeDateStamp() + ".csv",
    csv,
    "text/csv"
  );
}

function csvEscape(value) {
  const s = String(value ?? "");
  // Wrap if contains comma/quote/newline
  if (/[",\n\r]/.test(s)) {
    return '"' + s.replace(/"/g, '""') + '"';
  }
  return s;
}

function downloadTextFile(filename, content, mimeType) {
  const blob = new Blob([content], {type: mimeType});
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();

  setTimeout(() => URL.revokeObjectURL(url), 500);
}

function safeDateStamp() {
  const d = new Date();
  const yyyy = String(d.getFullYear());
  const mm = String(d.getMonth() + 1).padStart(2, "0");
  const dd = String(d.getDate()).padStart(2, "0");
  const hh = String(d.getHours()).padStart(2, "0");
  const mi = String(d.getMinutes()).padStart(2, "0");
  return `${yyyy}${mm}${dd}-${hh}${mi}`;
}

function getMaxSessionNumber() {
  if (history.length === 0) return currentSession || 1;
  return history.reduce((m, r) => Math.max(m, r.session || 1), 1);
}

function getSessionBounds(sessionNumber) {
  const rounds = history
    .filter(r => (r.session || 1) === sessionNumber)
    .slice();

  if (rounds.length === 0) return null;

  let minStart = new Date(rounds[0].start);
  let maxEnd = new Date(rounds[0].end);

  rounds.forEach(r => {
    const s = new Date(r.start);
    const e = new Date(r.end);
    if (s.getTime() < minStart.getTime()) minStart = s;
    if (e.getTime() > maxEnd.getTime()) maxEnd = e;
  });

  return { minStart, maxEnd };
}

function canCreateNewSessionAt(desiredStartDateTime) {
  if (!history.length) return true;

  let changeoverMins = parseInt(changeoverDurationInput.value, 10);
  if (!Number.isFinite(changeoverMins) || changeoverMins < 0) changeoverMins = (prefs.changeoverDuration || 0);

  return getSessionThatContains(desiredStartDateTime, changeoverMins) === null;
}




/** =========================
 *  Helpers
 *  ========================= */
function cryptoRandomId() {
  try {
    return (crypto && crypto.randomUUID) ? crypto.randomUUID() : ('id_' + Math.random().toString(16).slice(2) + Date.now());
  } catch (e) {
    return 'id_' + Math.random().toString(16).slice(2) + Date.now();
  }
}

function getLatestRound() {
  if (history.length === 0) return null;
  return history.reduce((acc, r) => ((r.createdAt || 0) > (acc.createdAt || 0) ? r : acc), history[0]);
}
function getLatestRoundId() {
  const latest = getLatestRound();
  return latest ? latest.id : null;
}

function formatDateDDMMYYYY(d) {
  const dd = String(d.getDate()).padStart(2, '0');
  const mm = String(d.getMonth() + 1).padStart(2, '0');
  const yyyy = String(d.getFullYear());
  return dd + '-' + mm + '-' + yyyy;
}
function formatTimeHHMM(d) {
  const hh = String(d.getHours()).padStart(2, '0');
  const mm = String(d.getMinutes()).padStart(2, '0');
  return hh + ':' + mm;
}
function dateKeyYYYYMMDD(d) {
  const yyyy = String(d.getFullYear());
  const mm = String(d.getMonth() + 1).padStart(2, '0');
  const dd = String(d.getDate()).padStart(2, '0');
  return yyyy + '-' + mm + '-' + dd;
}

function parseHHMM(hhmm) {
  const m = /^([0-1]?\d|2[0-3]):([0-5]\d)$/.exec(hhmm || '');
  if (!m) return null;
  return {h: parseInt(m[1], 10), m: parseInt(m[2], 10)};
}
function combineDateAndTime(dateYYYYMMDD, hhmm) {
  const t = parseHHMM(hhmm);
  const d = new Date();
  d.setSeconds(0, 0);

  const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(dateYYYYMMDD || '');
  if (m) {
    const yyyy = parseInt(m[1], 10);
    const mm = parseInt(m[2], 10) - 1;
    const dd = parseInt(m[3], 10);
    d.setFullYear(yyyy, mm, dd);
  }

  if (t) d.setHours(t.h, t.m, 0, 0);
  return d;
}

function defaultStartTimeHHMM() {
  const d = new Date();
  d.setSeconds(0, 0);
  const mins = d.getMinutes();
  const rounded = Math.ceil(mins / 5) * 5;
  d.setMinutes(rounded);
  return formatTimeHHMM(d);
}

function resetPlayerStats() {
  players.forEach(p => { p.games = 0; p.sitouts = 0; });
}

function recomputePlayerStatsFromHistory() {
  resetPlayerStats();
  if (history.length === 0) return;

  const rounds = history.slice().sort((a, b) => (a.createdAt || 0) - (b.createdAt || 0));
  let sess = rounds[0].session || 1;
  resetPlayerStats();

  rounds.forEach(r => {
    const s = r.session || 1;
    if (s !== sess) {
      sess = s;
      resetPlayerStats();
    }
    const inRound = [].concat(r.teamA || [], r.teamB || []);
    inRound.forEach(name => {
      const obj = players.find(pl => pl.name === name);
      if (obj) obj.games = (obj.games || 0) + 1;
    });
    (r.satOut || []).forEach(name => {
      const obj = players.find(pl => pl.name === name);
      if (obj) obj.sitouts = (obj.sitouts || 0) + 1;
    });
  });

  // refresh current pointers based on latest created round
  const latest = getLatestRound();
  if (latest) {
    currentSession = latest.session || 1;
    lastRoundStart = new Date(latest.start);
    lastRoundEnd = new Date(latest.end);
  }
}

/** =========================
 *  Event listeners
 *  ========================= */
addPlayerBtn.addEventListener('click', addPlayer);
playerNameInput.addEventListener('keyup', (e) => { if (e.key === 'Enter') addPlayer(); });

generateRoundBtn.addEventListener('click', generateNextRound);
newSessionBtn.addEventListener('click', startNewSessionNow);

exportCsvBtn.addEventListener('click', exportSchedulesToCsv);

clearAllBtn.addEventListener('click', clearSchedulesOnly);


// Persisted preference listeners
startDateInput.addEventListener('change', () => { prefs.startDate = startDateInput.value || prefs.startDate; savePrefs(); });
startTimeInput.addEventListener('change', () => { prefs.startTime = startTimeInput.value || prefs.startTime; savePrefs(); });
gameDurationInput.addEventListener('change', () => {
  const v = parseInt(gameDurationInput.value, 10);
  if (Number.isFinite(v) && v > 0) { prefs.gameDuration = v; savePrefs(); }
});
changeoverDurationInput.addEventListener('change', () => {
  const v = parseInt(changeoverDurationInput.value, 10);
  if (Number.isFinite(v) && v >= 0) { prefs.changeoverDuration = v; savePrefs(); }
});
document.querySelectorAll('input[name="randomMode"]').forEach(r => {
  r.addEventListener('change', () => {
    prefs.randomMode = document.querySelector('input[name="randomMode"]:checked').value;
    savePrefs();
  });
});

/** =========================
 *  Init
 *  ========================= */
loadState();
renderPlayers();
renderHistory();
})();
</script>
</body>
</html>
